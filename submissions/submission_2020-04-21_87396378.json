{
    "cmd": "ADD",
    "syn": 8,
    "name": "The Rod Polishers",
    "data": "\"\"\"\n __    __  ______  ______  __  __   ______  ______  \n/\\ \"-./  \\/\\  __ \\/\\  == \\/\\ \\/ /  /\\  ___\\/\\__  _\\ \n\\ \\ \\-./\\ \\ \\  __ \\ \\  __<\\ \\  _\"-.\\ \\  __\\\\/_/\\ \\/ \n \\ \\_\\ \\ \\_\\ \\_\\ \\_\\ \\_\\ \\_\\ \\_\\ \\_\\\\ \\_____\\ \\ \\_\\ \n  \\/_/  \\/_/\\/_/\\/_/\\/_/ /_/\\/_/\\/_/ \\/_____/  \\/_/ \n ______  ______  __  __  ______  __      ______     \n/\\  == \\/\\  __ \\/\\ \\_\\ \\/\\  __ \\/\\ \\    /\\  ___\\    \n\\ \\  __<\\ \\ \\/\\ \\ \\____ \\ \\  __ \\ \\ \\___\\ \\  __\\    \n \\ \\_\\ \\_\\ \\_____\\/\\_____\\ \\_\\ \\_\\ \\_____\\ \\_____\\  \n  \\/_/ /_/\\/_____/\\/_____/\\/_/\\/_/\\/_____/\\/_____/  \n\n\nPlayer class for the Market Royale game.\n\nThis module creates a player for the Market Royale game.\n\nAt the start of each turn, the player will:\n |Take stock of current inventory.\n |Take stock of current gold.\n |Tally gold on most recent previous market event.\n |Tally gold on most recent previous market colour change (if present).\n |Tally gold on most recent previous overdraft event.\n |Check glossary of researched information.\n |Check glossary of rumoured information. Rumours are information from other players.\n\nGiven the information, the player can do one of the following at the end of each turn:\n |Research current market.\n |Buy (product, amount) from current market.\n |Sell (product, amount) to current market.\n |Move to adjacent (market) from current market.\n |Pass turn and do nothing.\n\nAuthors: Syndicate 8 - MBusA2020 Module 2\n             Renee He            (h.he13@student.unimelb.edu.au)\n             Joshua Xujuang Lin  (xujiang.lin@student.unimelb.edu.au)\n             Ellie Meng          (h.meng2@student.unimelb.edu.au)\n             Isaac Pang          (i.pang2@student.unimelb.edu.au)\n             Tann Tan            (h.tan49@student.unimelb.edu.au)\n             Grace Zhu           (grace.zhu@student.unimelb.edu.au)\n\nTODO List:\n    - Refer to code comments\n    - Update docstrings\n\nDream TODO List:\n    - Machine Learning to predict where to go, maybe\n    - A*/BFS for optimisation of movement\n\"\"\"\n\nimport Command\nfrom BasePlayer import BasePlayer\nfrom collections import defaultdict, deque\nfrom operator import itemgetter as ig\nfrom random import sample\n\n\nclass Player(BasePlayer):\n    def __init__(self):\n        # Initialise the class without arguments\n        # Inherit the parent init properties\n        super().__init__()\n\n        # Set additional properties\n        self.turn = 0                           # how many turns taken in game:     0,1,..*\n        self.researched = []                    # researched markets:               [market1, market2..]\n        self.market_prices = {}                 # market prices from self/players:  {market:{product:[amount, price]}}\n        self.inventory = {}                     # record items in inventory:        {product:[amount, asset_cost]}\n        self.gold = 0                           # gold:                             0,1,..*\n        self.score = 0                          # score from inventory and gold:    0,1,..*\n        self.goal_acheived = False              # indicates whether goal achieved:  True/False\n        self.visited_node = defaultdict(int)    # location visit counts:            {location: times_visited}\n        self.loc = ''                           # player's current location:        str(market location)\n\n    # TODO _________________________________________________________________________________\n    # Add logic for selling. Most of it will be reverse of buying so leave it for now.\n    # ______________________________________________________________________________________\n    def take_turn(self, location, prices, info, bm, gm):\n        \"\"\"Player takes a turn with (hopefully) informed choices.\n        Player can take any one of the following turns:\n        - Research current market\n        - Buy from market\n        - Sell to market\n        - Move to adjacent market\n        - Pass turn\n        Args:\n            location (str): Current player location as a string\n            prices (dict): The market's current prices after turn order correction\n                           {product: (price, amount)}\n            info (dict): Prices of products from random markets from other players\n                         {market: {product: price}}\n            bm (list): A list of all nodes that are currently black markets\n            gm (list): A list of all nodes that are currently grey markets\n        Output:\n            cmd (tup): A tuple of (Command.CMD, data)\n        \"\"\"\n\n        # define the player location\n        self.loc = location\n\n        # add information from current market\n        self.save_market_prices(self.market_prices, prices)\n\n        # collect information from other player\n        self.collect_rumours(info)\n\n        # check if goal achieved\n        self.goal_acheived = self.check_goal(self.inventory, self.goal)\n\n        # if goal acheived\n        if self.goal_acheived:\n            return Command.PASS, None\n\n        # basic strategy if not yet acheive goal\n        else:\n            # search for a market that player can afford\n            destination = self.search_market(self.inventory, self.gold, self.goal)\n\n            # obtains the next step and the path to the target destination\n            # the target path will be required for some optimisation in future\n            next_step, target_path = self.get_next_step(destination)\n\n            # take next step to reach destination if any\n            if next_step:\n                return Command.MOVE, next_step\n\n            # already at destination:\n            else:\n                # reseach market if haven't\n                if not location in self.researched:\n                    self.researched.append(location)\n                    return Command.RESEARCH, location\n\n                else:\n                    # find out what we need to buy and proceed\n                    to_buy = self.purchase(self.inventory, self.gold, prices)\n\n                    return Command.BUY, to_buy\n\n    # TODO ______________________________________________________________________________________\n    # Complete the functions below. Please add/remove additional arguments as you need.\n    # Think of possible test cases for each of them too.\n    # __________________________________________________________________________________________\n    def collect_rumours(self, market_prices, info):\n        \"\"\"Collect intel from other players at the same location, then store it in self.market_prices.\n        Args:\n            market prices : {market:{product:[amount, price]}}\n                    dictionary of market and products and price they sell.\n            info : { market : {product:price} }\n                    dictionary of information from other players\n        Output: None\n        \"\"\"\n        pass\n\n    def save_market_prices(self, market_prices, prices):\n        \"\"\"Save current market prices information into self.market_prices.\n        Args:\n            market prices : {market:{product:(amount, price)}}\n                    dictionary of market and products and price they sell.\n            prices : {product : price}\n                    items and prices sold in current market.\n        Output: None\n        \"\"\"\n        pass\n\n    def check_goal(self, inventory, goal):\n        \"\"\"Check if goal is acheived by comparing inventory and goal. \n           Switch self.acheived_goal = True if acheived goal.\n        Args:\n            inventory : {product : price}\n                    dictionary of products in inventory.\n            goal : {product : price}\n                    dictionary of products required to acheive goal.\n        Output: None\n        \"\"\"\n\n        pass\n\n    def search_market(self, inventory, gold, location):\n        \"\"\"Given current location, inventory, gold, and goal, what is the best market to buy from.\n           What market to choose if doesn't have any researched/rumoured information?\n           Feel free to improvise and document the details here.\n        Args:\n            inventory : {product : price}\n                    dictionary of products in inventory.\n            goal : {product : price}\n                    dictionary of products required to acheive goal.\n            gold : int\n                    How many gold the player has currently.\n        Output: None\n        \"\"\"\n        pass\n\n    def purchase(self, inventory, gold, prices):\n        \"\"\"Return the item and anoubt to buy when player is at a destination market.\n           Update self inventory and gold too before returning.\n        Args:\n            inventory : {product : price}\n                    dictionary of products in inventory.\n            goal : {product : price}\n                    dictionary of products required to acheive goal.\n            prices : {product : price}\n                    prices of item in the market.\n        Output: (product, amount)\n        \"\"\"\n        return None\n\n    def compute_score(self, inventory, gold, goal):\n        \"\"\"Compute and return score.\n        Args:\n            inventory : {product : price}\n                    dictionary of products in inventory.\n            goal : {product : price}\n                    dictionary of products required to acheive goal.\n            gold : int\n                    How many gold the player has currently.\n        Output: score (int)\n        \"\"\"\n        pass\n\n    def get_next_step(self, target):\n        \"\"\"Finds the fastest path by employing a breadth-first search algorithm.\n        Since all edges are currently unweighted, only simplified breadth-first\n        while storing each previous node is required\n        \"\"\"\n        # TODO: need to update location before calling function\n        # TODO: This is not the best path, this is the path that takes the fewest turns.\n        # TODO: Update this with a check if the intermediary nodes are black or grey markets\n        # Set the starting location as the player's current location\n        start = self.loc\n        # Collect all the nodes in the given map\n        nodes = self.map.get_node_names()\n        assert target in nodes, \"Target node not found in map\"\n        # Since it is a BFS, all nodes necessarily have one previous node. This is required for the backtracking later\n        # All nodes will have a not None node except the starting node\n        # Example: None -> A -> B -> C :: Backtrack None <- A <- B <- C\n        previous = {node: None for node in nodes}\n        # Must only visit every node exactly once for a BFS\n        # Set current market as visited\n        visited = {node: False for node in nodes}\n        visited[start] = True\n        # Create a queue data structure for markets to visit. A queue is required for FIFO, we want to analyse all\n        # neighbouring nodes of the current node before we proceed.\n        queue = deque([start])\n        # Start looping through the map from the current node.\n        while queue:\n            # Identify the currently assessed node\n            current = queue.pop()\n            # If the current node is the target node, we are done we need to backtrack to the start to create the path\n            # to avoid re-sorting a list, we need a structure that would show the path from start to end, left -> right.\n            # We want to return the path and the steps taken to reach the target node.\n            if current == target:\n                path = deque()\n                while current:\n                    path.appendleft(current)\n                    current = previous[current]\n                # path provides the nodes to traverse in order, so the next node is the best next step\n                return path[1], path\n            # Collect the neighbours of this market and iterate over them.\n            neighbours = self.map.get_neighbours(current)\n            for n in neighbours:\n                # If the neighbours have not been visited, add them to the queue.\n                # Set the current node as the previous node for all neighbours.\n                if not visited[n]:\n                    queue.appendleft(n)\n                    visited[n] = True\n                    previous[n] = current\n\n    # ____________________________________________________________________________________________\n    #                                       END TODO\n    # ___________________________________________________________________________________________\n\n    def __repr__(self):\n        '''Define the representation of the Player as the state of\n        current attributes.\n        '''\n        s = str(self.__dict__)\n        return s\n\n\n# Write a main function for testing\ndef main():\n    import unittest\n    import random\n    from time import time\n    from Map import Map\n    import string\n\n    map_width = 200\n    map_height = 100\n    resolution_x = 2\n    resolution_y = 3\n\n    node_list = list(string.ascii_uppercase)[:10]\n    # keep a list of good seeds\n    good_seeds = [23624]\n    test_map = Map(node_list, map_width, map_height, resolution_x, resolution_y, seed=good_seeds[0])\n\n    print('map_data[\"node_positions\"]\\n')\n    test_map.pretty_print_node_positions()\n    print('map_data[\"node_graph\"]\\n')\n    test_map.pretty_print_node_graph()\n\n    test_map.pretty_print_map()\n\n    t1 = time()\n    p = Player()\n    p.set_map(test_map)\n    p.loc = 'A'\n    target = 'E'\n    next_step, path = p.get_next_step(target)\n    turns_req = len(path)\n    t2 = time()\n    interval = t2 - t1\n    print(f\"Player is at {p.loc}. The quickest path to {target} takes {turns_req} turns.\")\n    print(f\"The next stpe on the path {path} is\")\n    print(f\"Time taken {interval} seconds\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
}
{
  "cmd": "ADD",
  "syn": 8,
  "name": "",
  "data": "\"\"\"\n __    __  ______  ______  __  __   ______  ______\n/\\ \"-./  \\/\\  __ \\/\\  == \\/\\ \\/ /  /\\  ___\\/\\__  _\\\n\\ \\ \\-./\\ \\ \\  __ \\ \\  __<\\ \\  _\"-.\\ \\  __\\\\/_/\\ \\/\n \\ \\_\\ \\ \\_\\ \\_\\ \\_\\ \\_\\ \\_\\ \\_\\ \\_\\\\ \\_____\\ \\ \\_\\\n  \\/_/  \\/_/\\/_/\\/_/\\/_/ /_/\\/_/\\/_/ \\/_____/  \\/_/\n ______  ______  __  __  ______  __      ______\n/\\  == \\/\\  __ \\/\\ \\_\\ \\/\\  __ \\/\\ \\    /\\  ___\\\n\\ \\  __<\\ \\ \\/\\ \\ \\____ \\ \\  __ \\ \\ \\___\\ \\  __\\\n \\ \\_\\ \\_\\ \\_____\\/\\_____\\ \\_\\ \\_\\ \\_____\\ \\_____\\\n  \\/_/ /_/\\/_____/\\/_____/\\/_/\\/_/\\/_____/\\/_____/\n\n\nPlayer class for the Market Royale game.\n\nThis module creates a player for the Market Royale game.\n\nAt the start of each turn, the player will:\n |Take stock of current inventory.\n |Take stock of current gold.\n |Tally gold on most recent previous market event.\n |Tally gold on most recent previous market colour change (if present).\n |Tally gold on most recent previous overdraft event.\n |Check glossary of researched information.\n |Check glossary of rumoured information. Rumours are information from other players.\n\nGiven the information, the player can do one of the following at the end of each turn:\n |Research current market.\n |Buy (product, amount) from current market.\n |Sell (product, amount) to current market.\n |Move to adjacent (market) from current market.\n |Pass turn and do nothing.\n\nAuthors: Syndicate 8 - MBusA2020 Module 2\n             Renee He            (h.he13@student.unimelb.edu.au)\n             Joshua Xujuang Lin  (xujiang.lin@student.unimelb.edu.au)\n             Ellie Meng          (h.meng2@student.unimelb.edu.au)\n             Isaac Pang          (i.pang2@student.unimelb.edu.au)\n             Tann Tan            (h.tan49@student.unimelb.edu.au)\n             Grace Zhu           (grace.zhu@student.unimelb.edu.au)\n\nTODO List:\n    - Refer to code comments\n    - Update docstrings\n\nDream TODO List:\n    - Machine Learning to predict where to go, maybe\n    - A*/BFS for optimisation of movement\n\"\"\"\n\nimport Command\nfrom BasePlayer import BasePlayer\nfrom collections import defaultdict, deque\nimport random\nimport math\nimport copy\n\n\nclass Player(BasePlayer):\n    def __init__(self):\n        # Initialise the class without arguments\n        # Inherit the parent init properties\n        super().__init__()\n\n        # Set additional properties\n        self.turn = 0                              # how many turns taken in game:     0,1,..*\n        self.researched = set()                    # researched markets:               [market1, market2..]\n        self.market_prices = {}                    # market prices from self/players:  {market:{product:[amount, price]}}\n        self.inventory = defaultdict(lambda:(0,0)) # record items in inventory:        {product:(amount, asset_cost)}\n        self.gold = 0                              # gold:                             0,1,..*\n        self.score = 0                             # score from inventory and gold:    0,1,..*\n        self.goal_achieved = False                 # indicates whether goal achieved:  True/False\n        self.visited_node = defaultdict(int)       # location visit counts:            {location: times_visited}\n        self.loc = ''                              # player's current location\n        self.bonus = 10000                         # bonus points upon reaching goal\n        self.ctr = ''                              # the central market, currently unknown\n        self.target_loc = ''                       # target location after searching and pathing\n\n    # TODO _________________________________________________________________________________\n    # Add logic for selling. Most of it will be reverse of buying so leave it for now.\n    # ______________________________________________________________________________________\n    def take_turn(self, location, prices, info, bm, gm):\n        \"\"\"Player takes a turn with (hopefully) informed choices.\n        Player can take any one of the following turns:\n        - Research current market\n        - Buy from market\n        - Sell to market\n        - Move to adjacent market\n        - Pass turn\n        Args:\n            location (str): Current player location as a string\n            prices (dict): The market's current prices after turn order correction\n                           {product: (price, amount)}\n            info (dict): Prices of products from random markets from other players\n                         {market: {product: price}}\n            bm (list): A list of all nodes that are currently black markets\n            gm (list): A list of all nodes that are currently grey markets\n        Output:\n            cmd (tup): A tuple of (Command.CMD, data)\n        \"\"\"\n        # Increase turn counter\n        self.turn += 1\n\n        # define the player location\n        self.loc = location\n\n        # add information from current market\n        self.save_market_prices(prices)\n\n        # collect information from other player\n        self.collect_rumours(info)\n\n        print(\"PRINT SOMETHING!\")\n\n        # Determine current strategy\n        bg_set = set(bm + gm)\n\n        cmd = self.get_strategy(prices, bg_set)\n\n        return cmd\n\n    # TODO ______________________________________________________________________________________\n    # Complete the functions below. Please add/remove additional arguments as you need.\n    # Think of possible test cases for each of them too.\n    # __________________________________________________________________________________________\n\n    def get_strategy(self, prices, bg_set):\n        \"\"\"Returns a function that dictates the player's current strategy\n        Args:\n            prices (dict): Prices of market in current location\n            bm (list): List of black markets passed from take_turn\n            gm (list): List of grey markets passed from take_turn\n        Output:\n            cmd (tup): A tuple of Command.CMD, data, output by children functions\n        \"\"\"\n        # check if goal achieved\n        self.check_goal()\n\n        if self.turn == 1:\n            return self.first_turn(bg_set)\n\n        # The highest priority is if the player is in a black/grey market\n        # Player moves to the closest nearest white market\n        if self.loc in bg_set:\n            self.target_loc = self.nearest_white(self.loc, bg_set)\n            return Command.MOVE_TO, self.get_next_step(self.target_loc)\n\n        # While we don't have information on a third of the markets in the game\n        # Move\n        if len(self.market_prices.keys()) < len(self.map.get_node_names()) // 2:\n            return self.wander(prices, bg_set)\n\n        # Once we have enough information, try to achieve the goal\n        if not self.goal_achieved:\n            buying_market = self.search_market(bg_set)\n            if buying_market:\n                self.target_loc = buying_market\n                return self.move_to_buy(prices, bg_set)\n            else:\n                return self.wander(prices, bg_set)\n        else:\n            self.target_loc = self.ctr\n            next_step = self.get_next_step(self.ctr)\n            if next_step:\n                return Command.MOVE_TO, self.get_next_step(self.ctr)\n            else:\n                return Command.PASS, None\n\n    def wander(self, prices, bg_set):\n        if self.loc != self.target_loc:\n            if self.loc not in self.researched.union(bg_set):\n                self.researched.add(self.loc)\n                return Command.RESEARCH, None\n            else:\n                return Command.MOVE_TO, self.get_next_step(self.target_loc)\n        else:\n            if self.loc in self.researched.union(bg_set):\n                next_market = self.choose(bg_set, {self.loc})\n                if next_market:\n                    self.target_loc = next_market\n                    return self.wander(prices, bg_set)\n                else:\n                    return self.move_to_buy(prices, bg_set)\n            else:\n                self.researched.add(self.loc)\n                return Command.RESEARCH, None\n\n    def choose(self, bg_set, ignore_set):\n        markets = set(self.map.get_node_names())\n        researched = self.researched\n        avail = list(markets - researched - bg_set - ignore_set)\n        if avail:\n            return random.choice(avail)\n        else:\n            return None\n\n    def move_to_buy(self, prices, bg_set):\n        \"\"\"Function to continue along the path to the target\"\"\"\n        if self.loc != self.target_loc:\n            return Command.MOVE_TO, self.get_next_step(self.target_loc)\n        elif self.loc == self.target_loc:\n            if prices:\n                purchase_item = self.purchase(prices)\n                if purchase_item:\n                    return Command.BUY, self.purchase(prices)\n                else:\n                    return Command.PASS, None\n            return Command.RESEARCH, None\n\n    def first_turn(self, bg_set):\n        \"\"\"The set of instructions on the first turn of the player.\n        The player must get a sense of the map by following these steps.\n        1. Store the central market on the map.\n        2. Set the furthest node from the central market as target node.\n        3. Find the fastest path to the target.\n        4. Set the next node as the next step.\n        5. If the current location is a terminal node, switch to research strat.\n        Args:\n            bg_set (set): Set of black and grey markets\n            bm (list): Current list of black markets\n            gm (list): Current list of grey markets\n        Output:\n            cmd (tup): A tuple of (Command.CMD, data)\n        \"\"\"\n        # Set the central market\n        self.ctr, distances = self.central_market()\n\n        # Set the score to be equal to the amount of gold\n        self.score = self.gold\n\n        # Determine the furthest node from the central market\n        t1_target = max(distances, key=distances.get)\n\n        # If we are already at the maximum node, research the node\n        if self.loc == t1_target:\n            self.researched.add(self.loc)\n            self.target_loc = self.choose(bg_set, {self.loc})\n            return Command.RESEARCH, None\n\n        # Find the first, random white market closest to the target market\n        # This is done recursively until a white market is found\n        # On turn 1, white markets are expected\n        self.target_loc = self.nearest_white(t1_target, bg_set)\n        return Command.MOVE_TO, self.get_next_step(self.target_loc)\n\n    def nearest_white(self, target_market, bg_set, assessed=set()):\n        \"\"\"Returns the market location closest to the target market that is white\n        If the target market is white, returns the target\"\"\"\n        # return the target market if it is a white market\n        if target_market not in bg_set:\n            return target_market\n\n        # get the neighbours of the target market that have not been assessed\n        # if this set less the black/grey market set is not empty,\n        # return a random target white market\n        neighbours = self.map.get_neighbours(target_market)\n        neighbour_set = neighbours - assessed\n        white_set = neighbour_set - bg_set\n        if white_set:\n            return random.choice(list(white_set))\n\n        # otherwise, the assessed locations and all of the neighbours are black\n        # The assessed should be updated to include all neighbours\n        # and a random next_market chosen from any of the neighbour set\n        else:\n            assessed.add(target_market)\n            assessed = assessed.union(neighbour_set)\n            next_market = random.choice(list(neighbours))\n            return self.nearest_white(next_market, bg_set, assessed)\n\n    def collect_rumours(self, info):\n        \"\"\"Collect intel from other players at the same location, then store it in self.market_prices.\n        Args:\n            market prices : {market:{product:[price, amount]}}\n                    dictionary of market and products and price they sell.\n            info : { market : {product:price} }\n                    dictionary of information from other players\n        Output: None\n        \"\"\"\n        if info:\n            for market, information in info.items():\n                if not self.market_prices.get(market):\n                    self.market_prices[market] = {k: (v, None) for k, v in information.items()}\n\n    def save_market_prices(self, prices):\n        \"\"\"Save current market prices information into self.market_prices.\n        Args:\n            market (str): market location\n            prices (dict): {product: (price, amount)}\n                    items and prices sold in current market.\n        Output: None\n        \"\"\"\n        if prices:\n            self.market_prices[self.loc] = prices\n\n    def check_goal(self):\n        \"\"\"Check if goal is acheived by comparing inventory and goal.\n           Switch self.acheived_goal = True if acheived goal.\n        Args:\n            inventory : {product:[amount, asset_cost]}\n                    dictionary of products in inventory.\n            goal : dictionary {product:amount needed}\n                    dictionary of products required to acheive goal.\n        Output: None\n        \"\"\"\n        for prod, amount in self.goal.items():\n            if self.inventory[prod][1] < amount:\n                return None\n        self.goal_achieved = True\n        return None\n\n    def search_market(self, bg_set):\n        \"\"\"Given current location, inventory, gold, and goal, what is the best market to buy from.\n           What market to choose if doesn't have any researched/rumoured information?\n           Feel free to improvise and document the details here.\n        Args:\n            bg_set (set): Set of black and grey markets\n        Output:\n            target_market (str): returns the target market from search. If all information on markets\n                                 are black, returns None\n        \"\"\"\n        # self.market_prices   # market prices from self/players:  {market:{product:[price, amount]}}\n        # self.inventory record items in inventory:        {product:[amount, asset_cost]}\n        # get the product name which has not reached the goal\n        possible_targets = {product: [None, math.inf]\n                            for product, amount in self.goal.items()\n                            if self.inventory[product][0] < amount}\n        if possible_targets:\n            for market, info in self.market_prices.items():\n                # check if markets are white\n                if market not in bg_set:\n                    for product in possible_targets.keys():\n                        market_price = info[product][0]\n                        min_price = possible_targets[product][1]\n                        if (product in self.goal.keys()) and (market_price < min_price):\n                            possible_targets[product] = [market, market_price]\n        else:\n            return None\n        # calculate the distances to these markets\n        dist_to_target = {market: len(self.get_path_to(market))\n                          for market, price in possible_targets.values()}\n        # find the closest white market to achieve the goal\n        # TODO: if returns none, logic is required to find more markets and research\n        if dist_to_target:\n            target_market = min(dist_to_target, key=dist_to_target.get)\n        else:\n            target_market = None\n\n        return target_market\n\n    def purchase(self, this_market_info):\n        \"\"\"Return the item and amount to buy when player is at a destination market.\n            Update self inventory and gold too before returning.\n\n                1. Find required item to buy (item in goal and under target amount)\n                2. Calculate amount to buy\n                3. If there are multiple items to required select base on highest score \n                   after purchase         \n                4. update self inventory, gold, and return output.\n                \n            **Note This function is guaranteed to purchase a type of product even\n            when the market couldnt meet our demand to reduce complexity as the\n            score will be same/reduced when this happens. This is achieved by\n            setting initial max_score=0.    \n                \n        Args:\n            1. goal: {prod1:amt1, prod2:amt2}\n                a dictionary of products required to achieve goal.\n            2. inventory: {prod1:[amt1, asset_cost1], prod2:[amt2, asset_cost2]}\n                a dictionary of products, amount of products, cost spent buying the items in inventory.            \n            3. gold : gold_amt            \n            4. this_market_info: {prod1:(p1, amt1), prod2:(p2, amt2), prod3:(p3, amt3), prod4:(p4, amt4)}\n                a dictionary of prices of item in the current market.\n        Output: (product, amount)\n        \"\"\"\n        # TODO: the score needs to be calculated according to the current score, which is the current gold\n        #       and any other goal scores.\n        #       Perhaps include a score calculation and score attribute for the player to self track\n        max_score = -math.inf\n        buy_amt = 0\n        to_buy = None\n\n        # find the best item to buy\n        for product in this_market_info.keys():\n\n            # initialize dummy variables used to record after purchase inventory and gold to compute score         \n            tmp_inventory = copy.deepcopy(self.inventory)\n            tmp_gold = self.gold\n            \n            # if product is what we need\n            if product in self.goal.keys() and self.inventory[product][0] < self.goal[product]:\n                # tmp_amt = MIN(market available, affordable amount, required amount)                                                                \n                tmp_amt = min(this_market_info[product][1],\n                              self.gold // this_market_info[product][0],\n                              self.goal[product] - self.inventory[product][0])\n\n                # update dummy variables to reflect after purchase inventory and gold level\n                tmp_inventory[product] = (tmp_inventory[product][0] + tmp_amt,\n                                          tmp_amt * tmp_inventory[product][1] + this_market_info[product][0])\n                tmp_gold -= tmp_amt * this_market_info[product][0]\n\n                # compute score and update best item to buy\n                tmp_score = self.compute_score(tmp_inventory, tmp_gold, self.goal)\n                if tmp_score >= max_score:\n                    to_buy = product\n                    buy_amt = tmp_amt\n                    max_score = tmp_score\n        assert(to_buy is not None)\n        if to_buy:\n            # update self inventory/gold then return purchased item\n            cost = buy_amt * this_market_info[to_buy][0]\n            self.gold = self.gold - cost\n            self.inventory[to_buy] = (self.inventory[to_buy][0] + buy_amt, self.inventory[to_buy][1] + cost)\n            return to_buy, int(buy_amt)\n        else:\n            return None\n\n    def compute_score(self, inventory, gold, goal):\n        \"\"\"Compute and return score.\n        Args:\n            inventory: {prod1:[amt1, asset_cost1], prod2:[amt2, asset_cost2]}\n                a dictionary of products, amount of products, cost spent buying the items in inventory.   \n            goal : {product : price}\n                    dictionary of products required to acheive goal.\n            gold : int\n                    How many gold the player has currently.\n        Output: score (int)\n        \"\"\"\n        score = 0\n        # score for hitting target\n        for item in inventory.keys():\n            if inventory[item][0] >= goal[item]:\n                score += self.bonus\n\n        # include remaining gold\n        score += gold\n\n        return score\n\n    def get_next_step(self, target_location):\n        \"\"\"Returns the next step on the path required.\n        \"\"\"\n        shortest_path = self.get_path_to(target_location)\n\n        # Shortest path provides the nodes to traverse in order, so the next node is the best next step\n        # If the path is of length 1, the player is starting at the target node, so the function\n        # Returns None as the next step. Use an exception here instead of if statement\n        # for lower comparison overhead\n        try:\n            adjacent_market = shortest_path[1]\n        except (IndexError, TypeError):\n            adjacent_market = None\n        return adjacent_market\n\n    def get_path_to(self, target_location):\n        \"\"\"Finds the fastest path by employing a breadth-first search algorithm.\n        Since all edges are currently unweighted, only a simplified breadth-first\n        while storing each previous node is required\n        \"\"\"\n        # TODO: add some sort of priority queue with weights according to the market color\n        # Set the starting location as the player's current location\n        start = self.loc\n\n        # Collect all the nodes in the given map\n        nodes = self.map.get_node_names()\n\n        # Since it is a BFS, all nodes necessarily have one previous node. This is required for the backtracking later\n        # All nodes will have a not None node except the starting node\n        # Example: None -> A -> B -> C :: Backtrack None <- A <- B <- C\n        previous = {node: None for node in nodes}\n\n        # Must only visit every node exactly once for a BFS\n        # Set current market as visited\n        visited = {node: False for node in nodes}\n        visited[start] = True\n\n        # Create a queue data structure for markets to visit. A queue is required for FIFO, we want to analyse all\n        # neighbouring nodes of the current node before we proceed.\n        queue = deque([start])\n\n        # Start looping through the map from the current node.\n        # Identify the currently assessed node by popping the right of the queue\n        while queue:\n            current = queue.pop()\n\n            # If the current node is the target node, we are done we need to backtrack to the start to create the path\n            # to avoid re-sorting a list, we need a structure that would show the path from start to end, left -> right.\n            # We want to return the path and the steps taken to reach the target node.\n            if current == target_location:\n                path = deque()\n                while current:\n                    path.appendleft(current)\n                    current = previous[current]\n                return path\n\n            # Collect the neighbours of this market and iterate over them.\n            # If the neighbours have not been visited, add them to the queue\n            # Set the current node as the previous node for all neighbours.\n            neighbours = self.map.get_neighbours(current)\n            for n in neighbours:\n                if not visited[n]:\n                    queue.appendleft(n)\n                    visited[n] = True\n                    previous[n] = current\n\n\n    def dist_to(self, from_loc, to_loc):\n        \"\"\"Function to calculate the distance between two points\n        Args:\n            from_loc (tup): (x1, y1) starting coordinates\n            to_loc (tup): (x2, y2) ending coordinates\n        Output:\n            dist (float): distance between the coordinates as a result of\n                          sqrt((x2 - x1)^2 + (y2 - y1)^2)\n            \"\"\"\n        x1, y1 = from_loc\n        x2, y2 = to_loc\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    def central_market(self):\n        \"\"\"Function to determine which market is at the centre of the map\n        Player is meant to move to the central market toward the end of the game\n        \"\"\"\n        # To iterate only once over each node, the minimum distance is first\n        # initialised as a maximum possible distance, i.e. the corner of the\n        # map. The shape of the circle is also a rectangle, equivalent to the\n        # map dimensions. Therefore, the true safest market must satisfy the\n        # map ratios as well.\n        # If the current minimum distance is greater than the distance of\n        # the current node to the map center, reassign. This must be done\n        # while keeping the angle of incident to the map center in mind\n        map_center = self.map.map_width / 2, self.map.map_height / 2\n        map_corner = self.map.map_width, self.map.map_height\n        node_coords = self.map.map_data[\"node_positions\"]\n        map_ratio = self.map.map_width / self.map.map_height\n        min_dist = self.dist_to(map_corner, map_center)\n        distance_dict = dict()\n        for node, coord in node_coords.items():\n            coord = coord[:2]\n            current_dist = self.dist_to(coord, map_center)\n            current_ratio = coord[0] / coord[1]\n            distance_dict[node] = current_dist\n\n            # If more than 1 node is equidistant from the centre\n            # The player does not care which one he goes to\n            if min_dist >= current_dist and current_ratio <= map_ratio:\n                min_dist = current_dist\n                min_node = node\n\n        return min_node, distance_dict\n\n    # __________________________________________________________________________\n    #                              END TODO\n    # __________________________________________________________________________\n\n    def __repr__(self):\n        \"\"\"Define the representation of the Player as the state of\n        current attributes.\n        \"\"\"\n        s = str(self.__dict__)\n        return s\n\n\n# ========================= TESTS ===================================\n# TODO: Ensure Map & Game are imported for testing\n# TODO: Test cases need to be more organised with themes around test cases\n\nimport unittest\nimport string\nfrom itertools import cycle\nfrom Map import Map\n\n\n# Define the test suite for all test cases.\ndef suite():\n    # Test suite instance\n    test_suite = unittest.TestSuite()\n\n    # Map testing\n    test_suite.addTest(MapTestCase('test_central'))\n    test_suite.addTest(MapTestCase('test_search_market'))\n\n    # Movement testing\n    test_suite.addTest(MovementTestCase('test_move'))\n    test_suite.addTest(MovementTestCase('test_stay'))\n\n    # Knowledge testing\n    test_suite.addTest(KnowledgeTestCase('test_check_goal'))\n    test_suite.addTest(KnowledgeTestCase('test_rumours'))\n    test_suite.addTest(KnowledgeTestCase('test_prices'))\n\n    # Strategy testing\n    test_suite.addTest(StrategyTestCase('test_first_turn'))\n    test_suite.addTest(StrategyTestCase('test_purchase'))\n\n    return test_suite\n\n\n# Creates a test case class specifically for map identification.\nclass MapTestCase(unittest.TestCase):\n    # Tests if the output of a central market is correct.\n    # In this test case, there is exactly one central market.\n    def test_central(self):\n        p = Player()\n        p.map = test_map()\n        self.assertEqual(p.central_market()[0], \"V\")\n\n    def test_search_market(self):\n        p = Player()\n        p.map = test_static_map()\n        p.loc = \"E\"\n        prod = [\"Food\", \"Electronics\", \"Social\", \"Hardware\"]\n        goal = dict(zip(prod, [5]*len(prod)))\n        p.set_goal(goal)\n        nodes = p.map.get_node_names()\n        temp = list(zip(cycle(prod), map(list, enumerate(range(len(prod) * len(nodes))))))\n        temp2 = []\n        for i in range(len(nodes)):\n            temp2.append((nodes[i], dict(temp[(i*4):(4*(i+1))])))\n        p.market_prices = dict(temp2)\n        # p.market_prices should look like:\n        # {'A': {'Food': [0, 0],\n        #        'Electronics': [1, 1],\n        #        'Social': [2, 2],\n        #        'Hardware': [3, 3]},\n        #  'B': {'Food': [4, 4],\n        #        'Electronics': [5, 5],\n        #        'Social': [6, 6],\n        #        'Hardware': [7, 7]}}...\n        # test when inventory be empty with no bm and gm\n        target = p.search_market(set())\n        self.assertEqual(target, \"A\")\n        # test when black market is \"A\"\n        target = p.search_market(set(\"A\"))\n        self.assertEqual(target, 'B')\n        # test when goal is reached\n        p.inventory = dict(zip(prod, map(list, [(5, 0)] * len(prod))))\n        target = p.search_market(set())\n        self.assertIsNone(target)\n\n\n# Creates a test case class specifically for basic player movement.\nclass MovementTestCase(unittest.TestCase):\n    # Tests if the next step is definitely within the neighbouring nodes.\n    # Tests if the path length is correct.\n    def test_move(self):\n        p = Player()\n        p.map = test_map()\n        p.loc = \"A\"\n        target = \"V\"\n        next_step = p.get_next_step(target)\n        next_path = p.get_path_to(target)\n        self.assertTrue(next_step in p.map.get_neighbours(\"A\"))\n        self.assertEqual(len(next_path), 4)\n\n    # Tests if the next step is to stay put if the player arrives.\n    # Tests if the number of turns required is to stay still is 0.\n    def test_stay(self):\n        p = Player()\n        p.map = test_map()\n        p.loc = \"A\"\n        target = \"A\"\n        next_step = p.get_next_step(target)\n        next_path = p.get_path_to(target)\n        self.assertIsNone(next_step)\n        self.assertEqual(len(next_path), 1)\n\n\n# Creates test case class for player knowledge functions\nclass KnowledgeTestCase(unittest.TestCase):\n    # Tests if the check_goal function works correctly\n    def test_check_goal(self):\n        p = Player()\n        p.inventory['Food'] = [100, 10]\n        p.set_goal({'Food': 10})\n        p.check_goal()\n        self.assertTrue(p.goal_achieved)\n\n        p.set_goal({'Food': 20})\n        self.assertFalse(p.check_goal())\n\n    # Tests is if the collect rumours function works correctly\n    def test_rumours(self):\n        p = Player()\n        info = {\"A\": {'Food': 90,\n                      'Social': 60},\n                \"B\": {'Food': 80,\n                      'Social': 70}}\n        p.collect_rumours(info)\n        self.assertTrue(p.market_prices)\n        self.assertIsNone(p.market_prices[\"A\"][\"Food\"][1])\n        self.assertEqual(p.market_prices[\"B\"][\"Social\"][0], 70)\n        p.market_prices[\"A\"] = {'Food': [90, 100],\n                                'Social': [60, 50]}\n        p.collect_rumours(info)\n        self.assertIsNotNone(p.market_prices[\"A\"][\"Food\"][1])\n        self.assertEqual(p.market_prices[\"A\"][\"Social\"][1], 50)\n\n    # Tests if the save_market_prices function works correctly\n    def test_prices(self):\n        p = Player()\n        p.loc = \"A\"\n        prices = {'Food': [90, 100],\n                  'Social': [60, 50]}\n        p.save_market_prices(prices)\n        self.assertTrue(p.market_prices)\n        self.assertEqual(p.market_prices[\"A\"][\"Food\"], [90, 100])\n\n\n# Create a class for testing strategy.\nclass StrategyTestCase(unittest.TestCase):\n    # Testing first turn strategy\n    def test_first_turn(self):\n        p = Player()\n        p.map = test_map()\n        p.loc = \"V\"\n\n        # move to the furthest node, U\n        cmd, _ = p.first_turn(set())\n        self.assertEqual(cmd, Command.MOVE_TO)\n        self.assertEqual(p.target_loc, \"U\")\n\n        # move to the furthest node from V that is not U\n        cmd, _ = p.first_turn(set([\"U\"]))\n        self.assertEqual(cmd, Command.MOVE_TO)\n        self.assertNotEqual(p.target_loc, \"U\")\n        self.assertNotEqual(p.target_loc, \"V\")\n\n        # move to the furthest node from V that is not U or its neighbours\n        bm = [\"U\"]\n        gm = list(p.map.get_neighbours(\"U\"))\n        cmd, _ = p.first_turn(set(bm + gm))\n        self.assertEqual(cmd, Command.MOVE_TO)\n        self.assertNotEqual(p.target_loc, \"U\")\n        self.assertNotEqual(p.target_loc, \"V\")\n\n        # stay at the node and research\n        p.loc = \"U\"\n        cmd, next_step = p.first_turn(set())\n        self.assertEqual(cmd, Command.RESEARCH)\n        self.assertIsNone(next_step)\n\n    # Test the purchase function\n    def test_purchase(self):\n        p = Player()\n        goal = {'Food': 10, 'Social': 15}\n        p.set_goal(goal)\n        p.inventory['Food'] = (5, 0)\n        p.set_gold(500.0)\n        prices = {'Food': (100, 3),\n                  'Electronics': (300, 10),\n                  'Social': (150, 5),\n                  'Hardware': (350, 5)}\n        prod, amt = p.purchase(prices)\n        self.assertEqual(prod, 'Food')\n        self.assertEqual(amt, 3)\n\n\n# This function helps output the map for testing.\n# Allows the size and seed to be mutable.\ndef test_map(size=26, seed=23624):\n    assert(type(size) == int)\n    assert(1 <= size <= 26)\n    map_width = 200  # Dimensions of map\n    map_height = 100\n    res_x = 2  # Resolution to render the map at\n    res_y = 3\n    node_list = list(string.ascii_uppercase)[:size]\n    return Map(node_list, map_width, map_height, res_x, res_y, seed=seed)\n\n\n# This function helps output a static map for testing.\ndef test_static_map():\n    class StaticMap(Map):\n        def __init__(self, node_positions, node_graph, map_width, map_height, resolution_x, resolution_y):\n            self.map_data = {}\n            self.map_width = map_width\n            self.map_height = map_height\n            self.resolution_x = resolution_x\n            self.resolution_y = resolution_y\n\n            self.map_data[\"node_positions\"] = node_positions\n            self.map_data[\"node_graph\"] = node_graph\n\n            self.init_circle()\n\n            self.render_map()\n\n    node_pos = {\"A\": (100, 50, 0),\n                \"B\": (10, 50, 0),\n                \"C\": (100, 90, 0),\n                \"D\": (190, 50, 0),\n                \"E\": (100, 10, 0)}\n    node_graph = {'A': {'B', 'C', 'D', 'E'},\n                  'B': {'A', 'C', 'E'},\n                  'C': {'A', 'B', 'D'},\n                  'D': {'A', 'C', 'E'},\n                  'E': {'A', 'B', 'D'}}\n    return StaticMap(node_pos, node_graph, 200, 100, 2, 3)\n\n\nif __name__ == \"__main__\":\n    # Print visual diagnostics\n    player = Player()\n    player.map = test_map()\n    player.loc = \"A\"\n    central_market = player.central_market()[0]\n    next_step = player.get_next_step(central_market)\n    next_path = player.get_path_to(central_market)\n    player.map.pretty_print_map()\n    print(f\"From {player.loc}, the next step to {central_market} is {next_step}.\")\n    print(f\"The quickest path is {list(next_path)}. This takes {len(next_path)} turns.\")\n    print(f\"The central market is {central_market}\")\n\n    runner = unittest.TextTestRunner()\n    runner.run(suite())\n\n"
}

{
    "cmd": "ADD",
    "syn": 8,
    "name": "Holiday_Maker",
    "data": "\"\"\"\n __    __  ______  ______  __  __   ______  ______\n/\\ \"-./  \\/\\  __ \\/\\  == \\/\\ \\/ /  /\\  ___\\/\\__  _\\\n\\ \\ \\-./\\ \\ \\  __ \\ \\  __<\\ \\  _\"-.\\ \\  __\\\\/_/\\ \\/\n \\ \\_\\ \\ \\_\\ \\_\\ \\_\\ \\_\\ \\_\\ \\_\\ \\_\\\\ \\_____\\ \\ \\_\\\n  \\/_/  \\/_/\\/_/\\/_/\\/_/ /_/\\/_/\\/_/ \\/_____/  \\/_/\n ______  ______  __  __  ______  __      ______\n/\\  == \\/\\  __ \\/\\ \\_\\ \\/\\  __ \\/\\ \\    /\\  ___\\\n\\ \\  __<\\ \\ \\/\\ \\ \\____ \\ \\  __ \\ \\ \\___\\ \\  __\\\n \\ \\_\\ \\_\\ \\_____\\/\\_____\\ \\_\\ \\_\\ \\_____\\ \\_____\\\n  \\/_/ /_/\\/_____/\\/_____/\\/_/\\/_/\\/_____/\\/_____/\n\n\nPlayer class for the Market Royale game.\n\nThis module creates a player for the Market Royale game.\nThe player is modelled after a rational buyer with imperfect information of the market.\n\nAt the start of the game, the player will venture towards the external areas of the map,\nwhile collecting information along the way to increase the library of market information the player stores.\nUpon reaching a threshold, the player will calculate statistics of the markets to maximise profits.\n\nTo maximise profits, the player will visit the markets that have products for sale with prices under the 25th percentile\nof prices of markets known. The player will then visit the markets that will buy the products with prices over 75th\npercentile of prices of markets known.\n\nThe statistics of the market will update every turn as the player gains more information from passing players.\n\nThe player will also blacklist markets that have nothing for sale of a given product to inform decision making.\n\nTo avoid going into negative gold, the player will dump any acquired stock before proceeding with any other strategy.\n\nThe player is also very risk averse, preferring to avoid black and grey markets entirely. Since grey markets turn\nblack the next turn, the player is effectively treating grey markets as black markets.\n\nAt the start of each turn, the player will:\n |Take stock of current inventory.\n |Take stock of current gold.\n |Check glossary of market information\n |Update statistics on the markets\n |Decide on the strategies available, what to do with information\n\nGiven the information, the player can do one of the following at the end of each turn:\n |Research current market.\n |Buy (product, amount) from current market, and update inventory and gold.\n |Sell (product, amount) to current market, and update inventory and gold.\n |Move to adjacent (market) from current market.\n |Pass turn and do nothing.\n\nAuthors: Syndicate 8 - MBusA2020 Module 2\n             Isaac Pang          (i.pang2@student.unimelb.edu.au)\n             Tann Tan            (h.tan49@student.unimelb.edu.au)\n             Renee He            (h.he13@student.unimelb.edu.au)\n             Ellie Meng          (h.meng2@student.unimelb.edu.au)\n             Grace Zhu           (grace.zhu@student.unimelb.edu.au)\n             Joshua Xujuang Lin  (xujiang.lin@student.unimelb.edu.au)\n\nRoles:  Isaac  = Planning, Architecture, Optimisation, Strategy, Refactoring\n        Tann   = Pathing, Optimisation, Strategy\n        Renee  = Optimisation, Strategy & Statistics\n        Ellie  = Optimisation, Strategy, Foundational Functions\n        Grace  = Optimisation, Strategy, Player Finance Management\n        Joshua = Optimisation, Player Functions\n\nItems Authored (Work Breakdown):\n    Isaac:\n        get_strategy\n        wander\n        profit_max\n        opt_goal_achievement\n        excess_stock\n        any_excess\n        dump_stock\n        cut_losses\n        take_turn\n    Tann:\n        get_next_step\n        get_path_to\n        compute_score\n        central_market\n        nearest_white\n    Renee:\n        update_stats\n        buy_sell\n        profit_buy\n        profit_sell\n    Ellie:\n        save_market_prices\n        check_goal\n        collect_rumours\n        move_to_buy\n        search_market\n    Grace:\n        goal_purchase\n        afford_amount\n        afford_anything\n        update_inv_gold\n    Joshua:\n        __init__\n        __repr__\n        first_turn\n        choose\n        dist_to\n\"\"\"\n\nimport Command\nfrom BasePlayer import BasePlayer\nfrom collections import defaultdict, deque\nimport random\nimport math\nimport copy\nimport numpy as np\n\n\nclass Player(BasePlayer):\n    def __init__(self):\n        # Initialise the class without arguments\n        # Inherit the parent init properties\n        super().__init__()\n\n        # Set additional properties\n        self.turn = 0                                 # how many turns taken in game: 0,1,..*\n        self.max_turn = 300                           # maximum turns in a game\n        self.researched = set()                       # researched markets:           [market1, market2..]\n        self.market_prices = {}                       # prices from self/players:     {market:{product:[price, amount]}}\n        self.inventory = defaultdict(lambda: (0, 0))  # record items in inventory:    {product:(amount, asset_cost)}\n        self.gold = 0                                 # gold:                            0,1,..*\n        self.goal_achieved = False                    # indicates whether goal achieved: True/False\n        self.visited_node = defaultdict(int)          # location visit counts:           {location: times_visited}\n        self.loc = ''                                 # player's current location\n        self.bonus = 10000                            # bonus points upon reaching goal\n        self.ctr = ''                                 # the central market, currently unknown\n        self.target_loc = ''                          # target location after searching and pathing\n        self.black_penalty = 100                      # penalty for being in a black market\n        self.interest = 1.1                           # interest rate for overdrawn gold\n        self.blacklist = defaultdict(set)             # set of markets with no amount for each product\n        self.price_stats = {}                         # stats of market prices        {product: (price var, 75th, 25th)}\n        self.profit_order = []                        # A list of products in order to sell\n        self.final_turns = 0                          # The count of turns used at the end of the game\n\n    def take_turn(self, location, prices, info, bm, gm):\n        \"\"\"Player takes a turn with (hopefully) informed choices.\n        Player can take any one of the following turns:\n        - Research current market\n        - Buy from market\n        - Sell to market\n        - Move to adjacent market\n        - Pass turn\n        Args:\n            location (str): Current player location as a string\n            prices (dict): The market's current prices after turn order correction\n                           {product: (price, amount)}\n            info (dict): Prices of products from random markets from other players\n                         {market: {product: price}}\n            bm (list): A list of all nodes that are currently black markets\n            gm (list): A list of all nodes that are currently grey markets\n        Output:\n            cmd (tup): A tuple of (Command.CMD, data)\n        \"\"\"\n        # Increase turn counter\n        self.turn += 1\n\n        # Define the player location\n        self.loc = location\n\n        # Update gold\n        if self.gold < 0:\n            self.gold = self.interest * self.gold\n\n        # Blacklist the product in this market if there is nothing here\n        if prices:\n            for product in prices.keys():\n                if prices[product][1] == 0:\n                    self.blacklist[product].add(self.loc)\n\n        # Add information from current market\n        self.save_market_prices(prices)\n\n        # Collect information from other player\n        self.collect_rumours(info)\n\n        # Determine current strategy\n        cmd, data = self.get_strategy(prices, bm, gm)\n\n        # If the command is to buy, update the inventory and gold accordingly\n        if cmd == Command.BUY:\n            self.inventory, self.gold = self.update_inv_gold(prices, self.inventory, data[0], data[1], self.gold,\n                                                             action=0)\n        # If the command is to sell, update the inventory and gold accordingly\n        elif cmd == Command.SELL:\n            self.inventory, self.gold = self.update_inv_gold(prices, self.inventory, data[0], data[1], self.gold,\n                                                             action=1)\n\n        return cmd, data\n\n    def save_market_prices(self, prices):\n        \"\"\"Save current market prices information into self.market_prices.\n        Args:\n            prices (dict): {product: (price, amount)}\n                    items and prices sold in current market.\n        Output: None\n        \"\"\"\n        if prices:\n            self.market_prices[self.loc] = prices\n\n    def collect_rumours(self, info):\n        \"\"\"Collect intel from other players at the same location, then store it in self.market_prices.\n        Args:\n            market prices : {market:{product:[price, amount]}}\n                    dictionary of market and products and price they sell.\n            info : { market : {product:price} }\n                    dictionary of information from other players\n        Output: None\n        \"\"\"\n        if info:\n            for market, information in info.items():\n                if not self.market_prices.get(market):\n                    self.market_prices[market] = {k: (v, None) for k, v in information.items()}\n\n    def get_strategy(self, prices, bm, gm):\n        \"\"\"Returns a tuple that dictates the player's current strategy based on other strategy functions\n        This function determines strategy by a number of cascading if statements, similar to a simplified decision tree.\n        Args:\n            prices (dict): Prices of market in current location\n            bm (list): List of black markets passed from take_turn\n            gm (list): List of grey markets passed from take_turn\n        Output:\n            cmd (tup): A tuple of Command.CMD, data, output by other strategy functions\n        \"\"\"\n        # get the set of black and grey markets\n        bg_set = set(bm + gm)\n        bm = set(bm)\n\n        # check if goal achieved\n        self.check_goal()\n\n        # On the very first turn, while the player is safe, take stock of surroundings\n        # Player will decide movement or research according to position\n        if self.turn == 1:\n            return self.first_turn(bg_set)\n\n        # The highest priority is if the player is in a black/grey market\n        # Player moves to the nearest white market\n        # Player will change the target location every turn if the target location is located in the black/grey regions\n        if self.loc in bg_set:\n            if self.loc in bm:\n                self.gold -= self.black_penalty\n            if self.target_loc in bg_set or self.target_loc is None:\n                self.target_loc = self.nearest_white(self.loc, bg_set)\n            return Command.MOVE_TO, self.get_next_step(self.target_loc)\n\n        # Next highest priority:\n        # If the gold is negative, the player must cut losses by dumping inventory at the current market\n        if self.gold < 0:\n            if prices:\n                return self.cut_losses(prices)\n            else:\n                return Command.RESEARCH, None\n\n        # Next highest priority:\n        # Towards the end of the game, the player must go to the centre of the map to avoid complexity\n        # At the center of the map, the player dumps all his excess inventory to maximise score\n        if self.turn >= self.max_turn - self.final_turns:\n            return self.dump_stock(prices)\n\n        # Commence Phase 1:\n        # While we don't have information on a third of the markets in the game. Move around and research\n        if len(self.market_prices.keys()) < len(self.map.get_node_names()) // 2:\n            return self.wander(prices, bg_set)\n\n        # Update the statistical knowledge of the player every turn\n        self.update_stats(bg_set)\n\n        # Once we have enough information\n        # Commence Phase 2:\n        # With current gold, maximise profit by arbitrage.\n        # When a certain number of turns remain, proceed to buy with the purpose of achieving the goal\n        # Once the goal is achieved, the player will choose to maximise profits again\n        buy, sell = self.buy_sell(prices)\n        if self.turn < self.max_turn * 2 / 3:\n            target_market = self.search_market(bg_set, risk=0)\n            return self.profit_max(target_market, buy, sell, prices, bg_set)\n        elif not self.goal_achieved:\n            target_market = self.search_market(bg_set, risk=1)\n            return self.opt_goal_achievement(target_market, buy, prices, bg_set)\n        else:\n            target_market = self.search_market(bg_set, risk=1)\n            return self.profit_max(target_market, buy, sell, prices, bg_set, risk=1)\n\n    def check_goal(self):\n        \"\"\"Check if goal is achieved by comparing inventory and goal.\n           Switch self.achieved_goal = True if achieved goal.\n        \"\"\"\n        for prod, amount in self.goal.items():\n            if self.inventory[prod][0] < amount:\n                return None\n        self.goal_achieved = True\n        return None\n\n    def first_turn(self, bg_set):\n        \"\"\"The set of instructions on the first turn of the player.\n        The player must get a sense of the map by following these steps.\n        1. Store the central market on the map.\n        2. Set the furthest node from the central market as target node.\n        3. Find the fastest path to the target.\n        4. Set the next node as the next step.\n        5. If the current location is a terminal node, switch to research strat.\n        Args:\n            bg_set (set): Set of black and grey markets\n        Output:\n            cmd (tup): A tuple of (Command.CMD, data)\n        \"\"\"\n        # Set the central market\n        self.ctr, distances = self.central_market()\n\n        # Determine the furthest node from the central market\n        t1_target = max(distances, key=distances.get)\n\n        # Store information for the final turns needed for endgame.\n        # self.final_turns = len(self.get_path_to(t1_target)) + len(self.goal)\n        self.final_turns = len(self.goal)\n\n        # If we are already at the maximum node, research the node\n        if self.loc == t1_target:\n            self.researched.add(self.loc)\n            self.target_loc = self.choose(bg_set, {self.loc})\n            return Command.RESEARCH, None\n\n        # Find the first, random white market closest to the target market\n        # This is done recursively until a white market is found\n        # On turn 1, white markets are expected\n        self.target_loc = self.nearest_white(t1_target, bg_set)\n        return Command.MOVE_TO, self.get_next_step(self.target_loc)\n\n    def get_path_to(self, target_location):\n        \"\"\"Finds the fastest path by employing a breadth-first search algorithm.\n        Since all edges are currently unweighted, only a simplified breadth-first\n        while storing each previous node is required\n        \"\"\"\n        # Set the starting location as the player's current location\n        start = self.loc\n\n        # Collect all the nodes in the given map\n        nodes = self.map.get_node_names()\n\n        # Since it is a BFS, all nodes necessarily have one previous node. This is required for the backtracking later\n        # All nodes will have a not None node except the starting node\n        # Example: None -> A -> B -> C :: Backtrack None <- A <- B <- C\n        previous = {node: None for node in nodes}\n\n        # Must only visit every node exactly once for a BFS\n        # Set current market as visited\n        visited = {node: False for node in nodes}\n        visited[start] = True\n\n        # Create a queue data structure for markets to visit. A queue is required for FIFO, we want to analyse all\n        # neighbouring nodes of the current node before we proceed.\n        queue = deque([start])\n\n        # Start looping through the map from the current node.\n        # Identify the currently assessed node by popping the right of the queue\n        while queue:\n            current = queue.pop()\n\n            # If the current node is the target node, we are done we need to backtrack to the start to create the path\n            # to avoid re-sorting a list, we need a structure that would show the path from start to end, left -> right.\n            # We want to return the path and the steps taken to reach the target node.\n            if current == target_location:\n                path = deque()\n                while current:\n                    path.appendleft(current)\n                    current = previous[current]\n                return path\n\n            # Collect the neighbours of this market and iterate over them.\n            # If the neighbours have not been visited, add them to the queue\n            # Set the current node as the previous node for all neighbours.\n            neighbours = self.map.get_neighbours(current)\n            for n in neighbours:\n                if not visited[n]:\n                    queue.appendleft(n)\n                    visited[n] = True\n                    previous[n] = current\n\n    def dist_to(self, from_loc, to_loc):\n        \"\"\"Function to calculate the distance between two points\n        Args:\n            from_loc (tup): (x1, y1) starting coordinates\n            to_loc (tup): (x2, y2) ending coordinates\n        Output:\n            dist (float): distance between the coordinates as a result of\n                          sqrt((x2 - x1)^2 + (y2 - y1)^2)\n            \"\"\"\n        x1, y1 = from_loc\n        x2, y2 = to_loc\n        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    def central_market(self):\n        \"\"\"Function to determine which market is at the centre of the map\n        Player is meant to move to the central market toward the end of the game as part of risk aversion tactic\n        \"\"\"\n        # To iterate only once over each node, the minimum distance is first\n        # initialised as a maximum possible distance, i.e. the corner of the\n        # map. The shape of the circle is also a rectangle, equivalent to the\n        # map dimensions. Therefore, the true safest market must satisfy the\n        # map ratios as well.\n        #\n        # If the current minimum distance is greater than the distance of\n        # the current node to the map center, reassign. This must be done\n        # while keeping the angle of incident to the map center in mind\n        map_center = self.map.map_width / 2, self.map.map_height / 2\n        map_corner = self.map.map_width, self.map.map_height\n        node_coords = self.map.map_data[\"node_positions\"]\n        map_ratio = self.map.map_width / self.map.map_height\n        min_dist = self.dist_to(map_corner, map_center)\n        distance_dict = dict()\n        min_node = self.loc\n        for node, coord in node_coords.items():\n            coord = coord[:2]\n            current_dist = self.dist_to(coord, map_center)\n            current_ratio = coord[0] / coord[1]\n            distance_dict[node] = current_dist\n\n            # If more than 1 node is equidistant from the centre\n            # The player does not care which one he goes to\n            if min_dist >= current_dist and current_ratio <= map_ratio:\n                min_dist = current_dist\n                min_node = node\n\n        return min_node, distance_dict\n\n    def nearest_white(self, target_market, bg_set, assessed=set()):\n        \"\"\"Returns the market location closest to the target market that is white\n           If the target market is white, returns the target.\n        Args:\n            bg_set (set): Set of black and grey markets\n            target_market (str): Target market from search. \n        \n        Output:\n             (str): return the nearest white market from the current location\n        \"\"\"\n        # return the target market if it is a white market\n        if target_market not in bg_set:\n            return target_market\n\n        # Get the neighbours of the target market that have not been assessed\n        # If this set less the black/grey market set is not empty,\n        # Return a random target white market\n        neighbours = self.map.get_neighbours(target_market)\n        neighbour_set = neighbours - assessed\n        white_set = neighbour_set - bg_set\n        if white_set:\n            return random.choice(list(white_set))\n\n        # Otherwise, the assessed locations and all of the neighbours are black\n        # The assessed should be updated to include all neighbours and a random\n        # next_market chosen from any of the neighbour set\n        else:\n            assessed.add(target_market)\n            assessed = assessed.union(neighbour_set)\n            next_market = random.choice(list(neighbours))\n            return self.nearest_white(next_market, bg_set, assessed)\n\n    def cut_losses(self, prices):\n        \"\"\"Panic button function for the player to decide what part of his inventory to sell if goal is negative.\n        This avoids any further interest charges, the player will first dump any excess stock. If this function is\n        called without excess stock, the player will then choose which item that can be sold while maximising current\n        assets\"\"\"\n        # Price and inventory structure for reference\n        # Prices = {product: (prices, amounts)}\n        # Inventory = {product: (amount, cost)}\n        # Determine which product to dump if it is in excess.\n        excess_product = self.any_excess(set(prices.keys()))\n        if excess_product:\n            to_sell = excess_product\n            sell_num = self.excess_stock(excess_product)\n\n        # If there is no excess product, identify minimum asset loss\n        else:\n            final_assets = -math.inf\n            to_sell = None\n            sell_num = 0\n            for product, info in self.inventory.items():\n                # Calculate the number of the currently assessed product required to\n                # offset the negative gold cost\n                tmp_num = -int(self.gold // prices[product][0])\n                # Only consider the items in inventory that can fully amortise the negative gold\n                if info[0] >= tmp_num:\n                    # Assess the situation by creating a faux inventory for analysis\n                    tmp_inv = copy.deepcopy(self.inventory)\n                    tmp_inv, _ = self.update_inv_gold(prices, tmp_inv, product, tmp_num, gold=0, action=1)\n                    tmp_assets = sum([cost for amt, cost in tmp_inv.values()])\n                    if tmp_assets >= final_assets:\n                        final_assets = tmp_assets\n                        to_sell = product\n                        sell_num = tmp_num\n\n        # If the player does not have enough in his inventory, he will decide to dump the most expensive of\n        # any one of the player's inventory.\n        if to_sell is None:\n            to_sell = max(self.inventory, key=lambda x: self.inventory[x][0] * prices[x][0])\n            sell_num = self.inventory[to_sell][0]\n\n        # Return the command tuple for the stategy output\n        return Command.SELL, (to_sell, sell_num)\n\n    def excess_stock(self, product):\n        \"\"\"Function to determine the amount of excess stock of a given product.\n        Args:\n            product (str): Product currently assessed\n        Output:\n            (int): The number of items in the inventory of that product that is greater than the goal amount.\n            \"\"\"\n        return max(int(self.inventory[product][0] - self.goal[product]), 0)\n\n    def any_excess(self, sell_set):\n        \"\"\"Function to determine if any excess stock in sell set exists in player inventory.\n        The player should already be in a position to determine if the current market has a set of items that are\n        worthy of sale. This returns the product if the player has an excess of that product to sell for profit.\n        Args:\n            sell_set (set): The set of valid products to sell\n        Output:\n            product (str): the first product that is in excess\n        \"\"\"\n        for product in sell_set:\n            if self.excess_stock(product):\n                return product\n        return None\n\n    def dump_stock(self, prices):\n        \"\"\"Function to dump inventory at the end game to maximise score.\n        If the player has unsuccessfully reached goals, the player will sell all inventory\n        of that product that the player has.\n        Args:\n            prices (dict): The prices and amounts of items being sold at this market\n        Output:\n            cmd (tup): A command tuple Command.COMMAND, and associated viable data\n        \"\"\"\n        for product in prices.keys():\n            # If a particular product in inventory does not meet the goal and occupies inventory space\n            # Dump the item. Otherwise, sell any excess stock.\n            if 0 < self.inventory[product][0] < self.goal[product]:\n                to_dump = self.inventory[product][0]\n            else:\n                to_dump = self.excess_stock(product)\n\n            if to_dump:\n                return Command.SELL, (product, to_dump)\n        return Command.PASS, None\n\n    def wander(self, prices, bg_set):\n        \"\"\"Function for the player to wander relatively aimlessly in the map to collect more information in places that\n        has not been previously researched. This is invoked especially when not enough market information is avaialble.\n        Args:\n            prices (dict): The prices and amounts of items being sold at this market\n            bg_set (set): The set of black and grey markets in the game\n        Output:\n            cmd (tup): A command tuple Command.COMMAND, and associated viable data\n        \"\"\"\n        # If the current market is neither researched nor in the set of black and grey markets,\n        # research this market\n        if self.loc not in self.researched.union(bg_set):\n            self.researched.add(self.loc)\n            return Command.RESEARCH, None\n        else:\n            # Otherwise, check if we have arrived at a previously defined target market\n            # If the player has not reached his target, move to the next step towards that target\n            if self.loc != self.target_loc and self.target_loc is not None:\n                return Command.MOVE_TO, self.get_next_step(self.target_loc)\n            \n            # If the player has reached his target, choose a new location to wander to\n            else:\n                # If the player's only choice is the current node, the end game has been reached and\n                # no market is available. The player should pass to prevent excess charges.\n                new_choice = self.choose(bg_set, {self.loc})\n                if self.target_loc == new_choice:\n                    return Command.PASS, None\n\n                # Otherwise, set a new course for wandering!\n                self.target_loc = new_choice\n                return self.wander(prices, bg_set)\n\n    def choose(self, bg_set, ignore_set):\n        \"\"\"Function for the player to wander relatively aimlessly in the map to collect more information in places that\n        has not been previously researched. This is invoked especially when not enough market information is avaialble.\n        Args:\n            bg_set (set): The set of black and grey markets in the game\n            ignore_set (set): The set of locations to ignore when choosing where to go.\n        Output:\n            (str): A randomly chosen location subjected to the restraints of black and grey markets\n        \"\"\"\n        markets = set(self.map.get_node_names())\n        researched = self.researched\n        # First check if there are any available markets that have not been researched\n        # If there are any available markets, choose a random one to return\n        avail = list(markets - researched - bg_set - ignore_set)\n        if avail:\n            return random.choice(avail)\n        else:\n            # Check if there are any markets that are researched to return\n            avail = list(markets - bg_set - ignore_set)\n            if avail:\n                return random.choice(avail)\n\n            # The only case where the above set is empty is if the player is in the ignore_set\n            # In which case, just return a random location that is not in the black and grey set\n            else:\n                return random.choice(list(markets - bg_set))\n\n    def update_stats(self, bg_set):\n        \"\"\"Function to update player knowledge on statistics of the market the only useful \n        information to the player is a target region where the player can actually do business.\n        This function does not return anything as it is meant to update the class instances'\n        attributes\n        Args:\n            bg_set (set): Set of black and grey markets\n        Output: None\n        \"\"\"\n        product_price = defaultdict(list)\n\n        # The target region for the risk averse player is the region that does not include any\n        # black or grey markets. For this reason, the player will only update the statistics within\n        # this region.\n        target_region = set(self.market_prices.keys()) - bg_set\n        for market in target_region:\n            for product in self.market_prices[market].keys():\n                product_price[product].append(self.market_prices[market][product][0])\n\n        # Store the statistical information of the products\n        # price stats are: {product: (price variance, 75th percentile, 25th percentile)}\n        self.price_stats = {product: (np.var(product_price[product]),\n                                      np.percentile(product_price[product], 75),\n                                      np.percentile(product_price[product], 25))\n                            for product in product_price.keys()}\n\n        # The player will then create a list in order of their variances to determine which item\n        # will sell for the greatest profit. This is ordered in descending order to determine which\n        # item is required to trade first\n        target_list = sorted(self.price_stats.items(), key=lambda x: -x[1][0])[:5]\n        self.profit_order = [product[0] for product in target_list]\n\n        return None\n\n    def buy_sell(self, prices):\n        \"\"\" The purpose of selling is to maximise profit(buy low, sell high to take arbitrage).\n        To deem a product worth trading, the player assesses the variances of the product previously\n        calculated. Small variances implies the price of the product is stable, and there is no room\n        for arbitrage.\n        1. Make a target list consisting of the first 5 products as the products we aim to sell\n        2. Check if the market sells the target list products. If yes, go to step 3\n        3. Check if we are suppose to sell the products in this market, ie. is it the right place to sell?\n                 Decision making:\n                    If the price at this market is above eg. the 75th percentile of the all the prices \n                    for this product, it suggests it is the right place to sell\n                    --- Implication: if it's below 25th percentile, possibly a right place to buy\n                 If yes, go to step 4\n        4. Check if our inventory contains the target products which the market has\n                 If yes, go to step 5\n        5. Sell the target products\n        Args:\n            prices (dict): the market prices at the player's current location.\n        Output:\n            buy_set, sell_set (tup): A tuple of set() objects that contain the products that are\n            worthy of purchase (buy_set) or sale (sell_set)\n        \"\"\"\n        # Check if the market sells the target list products\n        to_trade = {target for target in self.profit_order if prices.get(target)}\n\n        # if the market doesn't sell the target products, function ends\n        if not to_trade:\n            return None, None\n\n        # check if it's the right market to sell\n        # While the market is the right one to sell, we must have the an amount in our inventory to sell\n        sell_set = {product for product in to_trade\n                    if prices[product][0] >= self.price_stats[product][1]\n                    and self.inventory[product][0] > 0}\n\n        # The right market to buy MUST have non-zero items to buy\n        buy_set = {product for product in to_trade\n                   if prices[product][0] <= self.price_stats[product][2]\n                   and prices[product][1] > 0}\n\n        \n        return buy_set, sell_set\n\n    def search_market(self, bg_set, risk=0):\n        \"\"\"Given current location, inventory, gold, and goal, what is the best market to buy from?\n           What market to choose if doesn't have any researched/rumoured information?\n           The action the player takes for the market to search is dependent on several factors,\n           most importantly if the player is risk taking or risk averse.\n           \n           If the player is risk taking, presumably the player will ignore the objective to reach\n           the goal; the player buys and sells purely for profit maximisation.\n\n           If the player is not, the player will achieve their goal and only buy and sell according\n           to keep goal amounts to gatekeep the score.\n\n        Args:\n            bg_set (set): Set of black and grey markets\n            risk (int): 0 if the player is attempting to buy and sell as much as possible\n                        1 if the player is only buying and selling to achieve the goal\n        Output:\n            target_market (str): returns the target market from search. If all information on markets\n                                 are black, returns None\n        \"\"\"\n        if risk:\n            # If the player is risk averse, the player wishes to first buy up to the goal amount\n            action = 0\n            product_targets = [product for product, amount in self.goal.items()\n                               if self.inventory[product][0] < amount]\n            # If this is empty, the player has reached the goal amount, and wishes to sell\n            # The player will sell any excess stock\n            if not product_targets:\n                action = 1\n                product_targets = [product for product in self.profit_order\n                                   if self.excess_stock(product)]\n                # If this is also empty, the player has only the minimum amount of goods\n                # The player must then choose to buy\n                if not product_targets:\n                    action = 0\n                    product_targets = self.profit_order\n\n        # If the player is not risk averse, the player will choose to buy or sell according to\n        # profit amounts\n        else:\n            action = 1\n            product_targets = [product for product in self.profit_order\n                               if self.inventory[product][0] > 0]\n            for product, stats in self.price_stats.items():\n                if self.gold > stats[2] and self.inventory[product][0] == 0:\n                    action = 0\n                    product_targets.append(product)\n                    break\n\n        # The player's target region is still one without black or grey markets, since the purchase\n        # function will empty our gold coffers completely, and we must avoid going into the\n        # negative.\n        target_region = set(self.market_prices.keys()) - bg_set\n        possible_targets = set()\n        if product_targets:\n            for market in target_region:\n                for product in product_targets:\n                    market_price = self.market_prices[market][product][0]\n                    if action == 0:\n                        # get the 25th percentile price of this product to buy\n                        curr_price = self.price_stats[product][2]\n\n                        # check if market is not blacklisted for this product\n                        if market not in self.blacklist[product]:\n                            if market_price < curr_price:\n                                possible_targets.add(market)\n                    else:\n                        # get the 75th percentile price of this product to sell\n                        curr_price = self.price_stats[product][1]\n                        if market_price > curr_price:\n                            possible_targets.add(market)\n\n        # calculate the distances to these markets\n        dist_to_target = {market: len(self.get_path_to(market))\n                          for market in possible_targets if market}\n        if dist_to_target:\n            target_market = min(dist_to_target, key=dist_to_target.get)\n        else:\n            target_market = None\n\n        return target_market\n\n    def profit_max(self, target_market, buy, sell, prices, bg_set, risk=0):\n        \"\"\"Switch function for the player to maximise profit instead of following the goal.\n        Args:\n            target_market (str): The location of market of interest as a result of market searching.\n            buy (set): The set of items to buy at the current location based on statistical knowledge\n            sell (set): The set of items to sell at the current location based on statistical knowledge\n            prices (dict): The market prices of the current location.\n            bg_set (set): The set of black and grey markets.\n            risk (int): 0 if the player is risk taking and purchasing for profit.\n                        1 if the player is risk averse and selling only excess stock.\n        Output:\n            cmd (tup): This function outputs a Command.CMD, data for a given command according to\n                       the function it calls.\n        \"\"\"\n        # If the player knows the prices of the current market, the player proceeds with deciding what todo\n        # If the player doesn't know, the player will research the market.\n        if prices:\n            # If the statistics of the player demands it, buy will be not empty\n            # The player then checks if he can afford to buy anything at this market\n            # If he can, he buys for profit.\n            if buy and self.afford_anything(prices, buy):\n                return self.profit_buy(prices, buy, bg_set)\n\n            # Otherwise, the player then checks if he has any excess stock if \n            # the current market is statistically relevant to sell.\n            # The player then chooses to sell according to the current risk taking\n            # behaviour.\n            elif sell and self.any_excess(sell):\n                return self.profit_sell(prices, sell, bg_set, risk)\n\n            # The player then decides if a target market has been acquired as a result\n            # of a previous search, and moves to that market to make a purchase decision.\n            elif target_market:\n                self.target_loc = target_market\n                return self.move_to_buy(prices, buy, bg_set)\n\n            # Otherwise, the player needs more market information, and must therefore\n            # wander the map\n            else:\n                return self.wander(prices, bg_set)\n\n        return Command.RESEARCH, None\n\n    def profit_buy(self, prices, buy_set, bg_set):\n        \"\"\"Function to decide how much to buy to maximise profit.\n        Args:\n            prices (dict): the current market prices\n            buy_set (set): the set of products to buy in this market\n            bg_set (set): the set of black and grey markets\n        Output:\n            cmd (tuple): Command.CMD, data tuple, depending on if a product is purchased or if more\n                         information is required.\n        \"\"\"\n        # If the player knows the prices of the current market, the player proceeds with deciding what todo\n        # If the player doesn't know, the player will research the market.\n        if not prices:\n            return Command.RESEARCH, None\n\n        # The player assesses the products in order of profit as previously decided.\n        # These products must be within the buy_set, which confirms that this market is within the\n        # 25th percentile of prices for buying purposes.\n        for product in self.profit_order:\n            if product in buy_set:\n                buy_amount = self.afford_amount(prices, product)\n                if buy_amount > 0:\n                    return Command.BUY, (product, buy_amount)\n\n        # If buy_set is empty, then the player needs to wander from the current location.\n        return self.wander(prices, bg_set)\n\n    def profit_sell(self, prices, sell_set, bg_set, risk=0):\n        \"\"\"Function to decide how much to sell to maximise profit.\n        Args:\n            prices (dict): the current market prices\n            sell_set (set): the set of products to sell in this market\n            bg_set (set): the set of black and grey markets\n            risk (int): 0 if the player is risk taking and purchasing for profit.\n                        1 if the player is risk averse and selling only excess stock.\n        Output:\n            cmd (tuple): Command.CMD, data tuple, depending on if a product is purchased or if more\n                         information is required.\n        \"\"\"\n        # If the player knows the prices of the current market, the player proceeds with deciding what todo\n        # If the player doesn't know, the player will research the market.\n        if not prices:\n            return Command.RESEARCH, None\n\n        # The player assesses the products in order of profit as previously decided.\n        # These products must be within the buy_set, which confirms that this market is within the\n        # 75th percentile of prices for buying purposes.\n        for product in self.profit_order:\n            if product in sell_set:\n                if risk:\n                    to_sell = self.excess_stock(product)\n                else:\n                    to_sell = self.inventory[product][0]\n                if to_sell:\n                    return Command.SELL, (product, to_sell)\n\n        # If sell_set is empty, then the player needs to wander from the current location.\n        return self.wander(prices, bg_set)\n\n    def afford_anything(self, market_prices, buy_set):\n        \"\"\"Boolean function if the player can afford anything at the current market\n        Args:\n            market_prices (dict): {market:{product:[price, amount]}}\n                                   dictionary of market and products and price they sell.\n            buy_set (set): set of products that are statistically worth buying at this market\n        \n        Output:\n            (bool): True - If anything is worth buying at this market\n                    False - If nothing is worth buying at this market\n        \"\"\"\n        if not buy_set:\n            return False\n        for product in buy_set:\n            if self.afford_amount(market_prices, product) > 0:\n                return True\n        return False\n\n    def opt_goal_achievement(self, target_market, buy, prices, bg_set):\n        \"\"\"Function to for the player to optimise to achieve the goal.\n        Args:\n            target_market (str): The target market for the player as a result of a market search.\n            buy (set): The set of items to buy at this market\n            prices (dict): The prices of this market\n            bg_set (set): The set of black and grey markets\n        Output:\n            cmd (tup): The tuple of Command.CMD, data as a result of either the buy or wander\n                       functions.\n        \"\"\"\n        # If the search market returns a worthy market, the player goes to the market\n        # with the aim to buy\n        if target_market:\n            self.target_loc = target_market\n            return self.move_to_buy(prices, buy, bg_set)\n\n        # Otherwise, the player must wander to gather more information.\n        else:\n            return self.wander(prices, bg_set)\n\n    def move_to_buy(self, prices, buy_set, bg_set):\n        \"\"\"Function that allows the player to continue moving with purpose, instead of wandering.\n        This function is normally called once a target market has been acquired and the player\n        does not want to waste time by wandering around other markets. Note that the searched market\n        changes dynamically every turn.\n        Args:\n            prices (dict): the prices of products at this market\n            buy_set (set): the set of items to buy that are statistically worth buying, at this\n                           market\n            bg_set (set): the set of black and grey markets\n        Output:\n            cmd (tuple): The tuple of Command.CMD, data\n        \"\"\"\n        # If the player has not arrived at the target location, move there with purpose.\n        if self.loc != self.target_loc:\n            return Command.MOVE_TO, self.get_next_step(self.target_loc)\n        \n        # otherwise, the player must have arrived at the location.\n        elif self.loc == self.target_loc:\n            # If the player knows the prices of the current market, the player proceeds with deciding what todo\n            # If the player doesn't know, the player will research the market.\n            if prices:\n                # player now assesses to buy products to achieve the goal.\n                # if the the goal has been achieved, purchase item returns None.\n                # the player then should choose to buy to maximise profit.\n                purchase_item = self.goal_purchase(prices)\n                if purchase_item:\n                    return Command.BUY, purchase_item\n                else:\n                    return self.profit_buy(prices, buy_set, bg_set)\n            return Command.RESEARCH, None\n\n    def goal_purchase(self, market_info):\n        \"\"\"Return the item and amount to buy when player is at a destination market, subjected to\n        the goal condition of the player's inventory.\n            1. Find required item to buy (item in goal and under target amount)\n            2. Calculate amount to buy\n            3. If there are multiple items to required select base on highest score\n               after purchase\n\n        Args:\n            market_info (dict): the prices of this market.\n        Output: \n            (product, amount) (tuple): The tuple of product and amount to buy of that product.\n                                       If the goal has been achieved, returns None.\n        \"\"\"\n        max_score = self.gold\n        buy_amt = 0\n        to_buy = None\n\n        # find the best item to buy\n        for product in market_info.keys():\n\n            # initialize dummy variables used to record after purchase inventory and gold to compute score\n            tmp_inventory = copy.deepcopy(self.inventory)\n            tmp_gold = self.gold\n\n            # if product is what we need\n            if product in self.goal.keys() and self.inventory[product][0] < self.goal[product]:\n                tmp_amt = min(int(self.afford_amount(market_info, product)),\n                              self.goal[product] - self.inventory[product][0])\n\n                # update dummy variables to reflect after purchase inventory and gold level\n                tmp_inventory, tmp_gold = self.update_inv_gold(market_info, tmp_inventory, product, tmp_amt,\n                                                               tmp_gold, action=0)\n\n                # compute score and update best item to buy\n                tmp_score = self.compute_score(tmp_inventory, tmp_gold, self.goal)\n                if tmp_score > max_score:\n                    to_buy = product\n                    buy_amt = int(tmp_amt)\n                    max_score = tmp_score\n        if to_buy is not None:\n            if buy_amt > 0:\n                return to_buy, buy_amt\n        else:\n            return None\n\n    def afford_amount(self, market_prices, product):\n        \"\"\"Compute the maximum amount the player can purchase of a particular product\n        at the current market.\n        Args:\n            market_prices (dict): the prices of this market\n            product (str): the product being assessed.\n        Output:\n            (int): The amount of the product that the player can afford to buy\n        \"\"\"\n        return int(min(market_prices[product][1],\n                       self.gold // market_prices[product][0]))\n\n    def compute_score(self, inventory, gold, goal):\n        \"\"\"Compute and return score.\n        Args:\n            inventory: {prod1:[amt1, asset_cost1], prod2:[amt2, asset_cost2]}\n                a dictionary of products, amount of products, cost spent buying the items in inventory.\n            goal : {product : price}\n                    dictionary of products required to acheive goal.\n            gold : int\n                    How many gold the player has currently.\n        Output: score (int)\n        \"\"\"\n        score = 0\n        # score for hitting target\n        for item in inventory.keys():\n            if inventory[item][0] >= goal[item]:\n                score += self.bonus\n\n        # include remaining gold\n        score += gold\n\n        return score\n\n    def update_inv_gold(self, prices, inv, prod, prod_amt, gold, action=0):\n        \"\"\"Helper function to update a given inventory and gold depending on the player action.\n        Args:\n            prices (dict): market prices in the format {product: (price, amount)}\n            inv (dict): inventory type in the format {product: (amount, asset cost)}\n            prod (str): the product to update the inventory\n            prod_amt (int): the amount of product to update the inventory\n            gold (float): the amount of starting gold\n            action (int): 0 if the player is buying\n                          1 if the player is selling\n        Output:\n            inv (dict): Updated dictionary\n            gold (float): Updated gold\n        \"\"\"\n        # If the player is buying, reduce inventory and increase gold accordingly\n        if action == 0:\n            inv[prod] = (inv[prod][0] + prod_amt,\n                         prod_amt * prices[prod][0] + inv[prod][1])\n            gold -= prod_amt * prices[prod][0]\n\n        # If the player is selling, do the reverse\n        else:\n            single_cost = inv[prod][1] / inv[prod][0]\n            inv[prod] = (inv[prod][0] - prod_amt,\n                         max(inv[prod][1] - prod_amt * single_cost, 0))\n            gold += prod_amt * prices[prod][0]\n\n        return inv, gold\n\n    def get_next_step(self, target_location):\n        \"\"\"Returns the next step on the path required, since the player can only move to an adjacent\n        market.\n        Args:\n            target_location (str): The target location to move to.\n        Output:\n            adjacent_market (str): The market to go to. If the player is already at the target,\n                                   returns None\n        \"\"\"\n        shortest_path = self.get_path_to(target_location)\n\n        # Shortest path provides the nodes to traverse in order, so the next node is the best next step\n        # If the path is of length 1, the player is starting at the target node, so the function\n        # Returns None as the next step. Use an exception here instead of if statement\n        # for lower comparison overhead\n        try:\n            adjacent_market = shortest_path[1]\n        except (IndexError, TypeError):\n            adjacent_market = None\n\n        return adjacent_market\n\n\n    def __repr__(self):\n        \"\"\"Define the representation of the Player as the state of\n        current attributes.\n        \"\"\"\n        s = str(self.__dict__)\n        return s\n\n\n# ========================= TESTS ===================================\n\nimport unittest\nimport string\nfrom itertools import cycle\nfrom Map import Map\n\n\n# Define the test suite for all test cases.\ndef suite():\n    # Test suite instance\n    test_suite = unittest.TestSuite()\n\n    # Map testing\n    test_suite.addTest(MapTestCase('test_central'))\n    # test_suite.addTest(MapTestCase('test_search_market'))\n\n    # Movement testing\n    test_suite.addTest(MovementTestCase('test_move'))\n    test_suite.addTest(MovementTestCase('test_stay'))\n\n    # Knowledge testing\n    test_suite.addTest(KnowledgeTestCase('test_check_goal'))\n    test_suite.addTest(KnowledgeTestCase('test_rumours'))\n    test_suite.addTest(KnowledgeTestCase('test_prices'))\n    test_suite.addTest(KnowledgeTestCase('test_buy_sell'))\n\n    # Strategy testing\n    test_suite.addTest(StrategyTestCase('test_first_turn'))\n    test_suite.addTest(StrategyTestCase('test_purchase'))\n\n    return test_suite\n\n\n# Creates a test case class specifically for map identification.\nclass MapTestCase(unittest.TestCase):\n    # Tests if the output of a central market is correct.\n    # In this test case, there is exactly one central market.\n    def test_central(self):\n        p = Player()\n        p.map = test_map()\n        self.assertEqual(p.central_market()[0], \"V\")\n\n    # Superceded test\n    # def test_search_market(self):\n    #     p = Player()\n    #     p.map = test_static_map()\n    #     p.loc = \"E\"\n    #     prod = [\"Food\", \"Electronics\", \"Social\", \"Hardware\"]\n    #     goal = dict(zip(prod, [5]*len(prod)))\n    #     p.set_goal(goal)\n    #     nodes = p.map.get_node_names()\n    #     temp = list(zip(cycle(prod), map(list, enumerate(range(len(prod) * len(nodes))))))\n    #     temp2 = []\n    #     for i in range(len(nodes)):\n    #         temp2.append((nodes[i], dict(temp[(i*4):(4*(i+1))])))\n    #     p.market_prices = dict(temp2)\n    #     # p.market_prices should look like:\n    #     # {'A': {'Food': [0, 0],\n    #     #        'Electronics': [1, 1],\n    #     #        'Social': [2, 2],\n    #     #        'Hardware': [3, 3]},\n    #     #  'B': {'Food': [4, 4],\n    #     #        'Electronics': [5, 5],\n    #     #        'Social': [6, 6],\n    #     #        'Hardware': [7, 7]}}...\n    #     # test when inventory be empty with no bm and gm\n    #     target = p.search_market(set(), risk=1)\n    #     self.assertEqual(target, \"A\")\n    #     # test when black market is \"A\"\n    #     target = p.search_market(set(\"A\"), risk=1)\n    #     self.assertEqual(target, 'B')\n    #     # test when goal is reached\n    #     p.inventory = dict(zip(prod, map(list, [(5, 0)] * len(prod))))\n    #     target = p.search_market(set(), risk=1)\n    #     self.assertIsNone(target)\n\n\n# Creates a test case class specifically for basic player movement.\nclass MovementTestCase(unittest.TestCase):\n    # Tests if the next step is definitely within the neighbouring nodes.\n    # Tests if the path length is correct.\n    def test_move(self):\n        p = Player()\n        p.map = test_map()\n        p.loc = \"A\"\n        target = \"V\"\n        next_step = p.get_next_step(target)\n        next_path = p.get_path_to(target)\n        self.assertTrue(next_step in p.map.get_neighbours(\"A\"))\n        self.assertEqual(len(next_path), 4)\n\n    # Tests if the next step is to stay put if the player arrives.\n    # Tests if the number of turns required is to stay still is 0.\n    def test_stay(self):\n        p = Player()\n        p.map = test_map()\n        p.loc = \"A\"\n        target = \"A\"\n        next_step = p.get_next_step(target)\n        next_path = p.get_path_to(target)\n        self.assertIsNone(next_step)\n        self.assertEqual(len(next_path), 1)\n\n\n# Creates test case class for player knowledge functions\nclass KnowledgeTestCase(unittest.TestCase):\n    # Tests if the check_goal function works correctly\n    def test_check_goal(self):\n        p = Player()\n        p.inventory['Food'] = [100, 10]\n        p.set_goal({'Food': 10})\n        p.check_goal()\n        self.assertTrue(p.goal_achieved)\n\n        p.set_goal({'Food': 20})\n        self.assertFalse(p.check_goal())\n\n    # Tests is if the collect rumours function works correctly\n    def test_rumours(self):\n        p = Player()\n        info = {\"A\": {'Food': 90,\n                      'Social': 60},\n                \"B\": {'Food': 80,\n                      'Social': 70}}\n        p.collect_rumours(info)\n        self.assertTrue(p.market_prices)\n        self.assertIsNone(p.market_prices[\"A\"][\"Food\"][1])\n        self.assertEqual(p.market_prices[\"B\"][\"Social\"][0], 70)\n        p.market_prices[\"A\"] = {'Food': [90, 100],\n                                'Social': [60, 50]}\n        p.collect_rumours(info)\n        self.assertIsNotNone(p.market_prices[\"A\"][\"Food\"][1])\n        self.assertEqual(p.market_prices[\"A\"][\"Social\"][1], 50)\n\n    # Tests if the save_market_prices function works correctly\n    def test_prices(self):\n        p = Player()\n        p.loc = \"A\"\n        prices = {'Food': [90, 100],\n                  'Social': [60, 50]}\n        p.save_market_prices(prices)\n        self.assertTrue(p.market_prices)\n        self.assertEqual(p.market_prices[\"A\"][\"Food\"], [90, 100])\n\n    def test_buy_sell(self):\n        p1 = Player()\n        gold = 1000.0\n        goal = {\"Food\": 10, \"Social\": 15}\n        market_prices = {'A': {'Food': (109, 700),\n                               'Electronics': (755, 210),\n                               'Social': (47, 1400),\n                               'Hardware': (881, 35)},\n                         'B': {'Food': (95, 700),\n                               'Electronics': (384, 210),\n                               'Social': (49, 1400),\n                               'Hardware': (633, 35)},\n                         'C': {'Food': (80, 700),\n                               'Electronics': (382, 210),\n                               'Social': (46, 1400),\n                               'Hardware': (432, 35)},\n                         'D': {'Food': (113, 700),\n                               'Electronics': (782, 210),\n                               'Social': (73, 1400),\n                               'Hardware': (537, 35)}}\n        p1.set_gold(gold)\n        p1.set_goal(goal)\n        p1.inventory[\"Food\"] = (5, 150)\n        p1.market_prices = market_prices\n        p1.update_stats(set())\n        prices = {'Food': (113, 700),\n                  'Electronics': (794, 210),\n                  'Social': (64, 1400),\n                  'Hardware': (597, 35)}\n        buy, sell = p1.buy_sell(prices)\n        self.assertFalse(buy)\n        self.assertTrue(sell)\n\n\n# Create a class for testing strategy.\nclass StrategyTestCase(unittest.TestCase):\n    # Testing first turn strategy\n    def test_first_turn(self):\n        p = Player()\n        p.map = test_map()\n        p.loc = \"V\"\n        goal = {'Food': 10,\n                'Electronics': 10,\n                'Social': 10,\n                'Hardware': 10}\n        p.set_goal(goal)\n\n        # move to the furthest node, U\n        cmd, _ = p.first_turn(set())\n        self.assertEqual(cmd, Command.MOVE_TO)\n        self.assertEqual(p.target_loc, \"U\")\n\n        # move to the furthest node from V that is not U\n        cmd, _ = p.first_turn(set([\"U\"]))\n        self.assertEqual(cmd, Command.MOVE_TO)\n        self.assertNotEqual(p.target_loc, \"U\")\n        self.assertNotEqual(p.target_loc, \"V\")\n\n        # move to the furthest node from V that is not U or its neighbours\n        bm = [\"U\"]\n        gm = list(p.map.get_neighbours(\"U\"))\n        cmd, _ = p.first_turn(set(bm + gm))\n        self.assertEqual(cmd, Command.MOVE_TO)\n        self.assertNotEqual(p.target_loc, \"U\")\n        self.assertNotEqual(p.target_loc, \"V\")\n\n        # stay at the node and research\n        p.loc = \"U\"\n        cmd, next_step = p.first_turn(set())\n        self.assertEqual(cmd, Command.RESEARCH)\n        self.assertIsNone(next_step)\n\n    # Test the purchase function\n    def test_purchase(self):\n        p = Player()\n        goal = {'Food': 10, 'Social': 15}\n        p.set_goal(goal)\n        p.inventory['Food'] = (5, 0)\n        p.set_gold(500.0)\n        prices = {'Food': (100, 3),\n                  'Electronics': (300, 10),\n                  'Social': (150, 5),\n                  'Hardware': (350, 5)}\n        self.assertIsNone(p.goal_purchase(prices))\n\n        prices['Food'] = (100, 5)\n        prod, amt = p.goal_purchase(prices)\n        self.assertEqual(prod, 'Food')\n        self.assertEqual(amt, 5)\n\n\n# This function helps output the map for testing.\n# Allows the size and seed to be mutable.\ndef test_map(size=26, seed=23624):\n    assert(type(size) == int)\n    assert(1 <= size <= 26)\n    map_width = 200  # Dimensions of map\n    map_height = 100\n    res_x = 2  # Resolution to render the map at\n    res_y = 3\n    node_list = list(string.ascii_uppercase)[:size]\n    return Map(node_list, map_width, map_height, res_x, res_y, seed=seed)\n\n\n# This function helps output a static map for testing.\ndef test_static_map():\n    class StaticMap(Map):\n        def __init__(self, node_positions, node_graph, map_width, map_height, resolution_x, resolution_y):\n            self.map_data = {}\n            self.map_width = map_width\n            self.map_height = map_height\n            self.resolution_x = resolution_x\n            self.resolution_y = resolution_y\n\n            self.map_data[\"node_positions\"] = node_positions\n            self.map_data[\"node_graph\"] = node_graph\n\n            self.init_circle()\n\n            self.render_map()\n\n    node_pos = {\"A\": (100, 50, 0),\n                \"B\": (10, 50, 0),\n                \"C\": (100, 90, 0),\n                \"D\": (190, 50, 0),\n                \"E\": (100, 10, 0)}\n    node_graph = {'A': {'B', 'C', 'D', 'E'},\n                  'B': {'A', 'C', 'E'},\n                  'C': {'A', 'B', 'D'},\n                  'D': {'A', 'C', 'E'},\n                  'E': {'A', 'B', 'D'}}\n    return StaticMap(node_pos, node_graph, 200, 100, 2, 3)\n\n\nif __name__ == \"__main__\":\n    # # Print visual diagnostics\n    # player = Player()\n    # player.map = test_map()\n    # player.loc = \"A\"\n    # central_market = player.central_market()[0]\n    # next_step = player.get_next_step(central_market)\n    # next_path = player.get_path_to(central_market)\n    # player.map.pretty_print_map()\n    # print(f\"From {player.loc}, the next step to {central_market} is {next_step}.\")\n    # print(f\"The quickest path is {list(next_path)}. This takes {len(next_path)} turns.\")\n    # print(f\"The central market is {central_market}\")\n\n    runner = unittest.TextTestRunner()\n    runner.run(suite())\n\n"
}